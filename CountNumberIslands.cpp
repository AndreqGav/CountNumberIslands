/*
Задача:
Дан массив, состоящий из нулей и единиц. Нули означают воду, единицы – сушу. Определить количество островов.
Например, в данном случае островов три:

1 1 0 0 0 0 0 0
1 1 0 0 0 0 1 0
0 1 0 0 0 0 0 0
0 0 1 1 1 0 0 0
0 1 1 1 0 0 0 0

***** Немного сути ****
Заданный массив будем называть картой и задаваться он будет как талица n на m (n строк и m столбцов)

Мы будем пробегаться по таблице и считать поиском с возвратом осторова.
То есть, проходим по каждой точке таблицы и если эта точка еще не посещалась и она является островом (равна 1), то увеличиваем счетчик островов и
применяем к ней алгоритм поиска с возвратом.

Поиск с возвратом:
Суть в данной задаче такова, что начиная с какой-то точки отсрова мы должны посетить все вершины этого острова (посетить - значить пометить врешину)

Как работает:
Начиная с какой-то вершины острова мы смотрим: можно ли шагнуть влево/вправо/вверх/вниз (можно значит индекс точки не будет выходить из границ массива)
И если можно сделать шаг мы смотрим, была ли посещена(помечена) эта точка ранее, если нет и она является сушой(равна 1), то применяем рекурсивно к этой точке точно такой же алгоритм
И так идет до тех пор, пока у точки не останется соседних непосещенных вершин, которые являются сушой - тогда по обратному шагу рекурсии вернемся к той точке,
откуда попали в эту и продолжим поиск с нее и так далее пока не вернемся к самой первой точке(откуда начали искать) этого алгоритма и
если у нее нет соседних непосещеных вершных являющихся сушой
(если есть, то алгоритм продолжается и мы снова вернемся к этой точке и у нее рано или поздно не будет соседних вершин явл. сушой)  - это будет означать,
что все точки острова посещены(помечены)
Далее программа вернется туда, откуда была вызвана функция поиска и продолжит бежать по карте, пока не встретит непосещенную вершину являющейся сушей и т.д
И так пока не пробежит по всей карте
После чего можно напечатать на экран полученный результат.

*/

#include <iostream>
#include <fstream>
#include "string.h"

using namespace std;

// Структура, представляющая собой точку на карте.
struct Point
{
	int i, j; // координаты точки.
	int value; // значение (1 - суша, 0 - вода).
	bool isMarked; // флаг, посещена ли была точка или нет.
};

int CountNumberIslands(string fileName = "input.txt");
void MarkIsland(Point** table, int n, int m, Point point);
void PrintTable(Point** table, int n, int m);

int main()
{
	setlocale(LC_ALL, "Russian");

	int count = CountNumberIslands();
	cout << "Кол-во найденых островов: " << count << endl;

	system("pause");
}

// Подсчет кол-во островов.
// параметры:
// fileName - имя файла, хранящем данные о карте. 
int CountNumberIslands(string fileName)
{
	int n, m; // размер таблицы.
	int count = 0; // кол-во островов.
	Point** table; // карта островов (представляет собой двумерный массив(таблицу) точек)

	fstream stream(fileName); // открываем поток файла
	/*
	Немного о файле:
	В первой строчке файла хранится кол-во строк таблицы
	Во второй строчке файла хранится кол-во столбцов таблицы
	Далее хранится сама таблица
	*/

	stream >> n; // считать кол-во строк.
	stream >> m; // считать кол-во столбцов.

	// инициализаци карты.
	table = new Point * [n];
	for (int i = 0; i < n; i++)
		table[i] = new Point[m];

	// считывание карты с файла
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			stream >> table[i][j].value; // считвть значение (суша или вода)
			table[i][j].isMarked = false; // пометить точку, как НЕпосещенную
			// установить координаты точки
			table[i][j].i = i;
			table[i][j].j = j;
		}
	}
	// выписать на экран карту.
	PrintTable(table, n, m);

	// пробегаем по карте и если точка является сушой и она не была посещена ранее, то увеличиваем счетчик островов и применяем алгоритм с возвратом к ней 
	// (то есть обходим остров, к которому принадлежит эта точка и помечаем все точки как посещенные)
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (!table[i][j].isMarked && table[i][j].value == 1)
			{
				count++;
				MarkIsland(table, n, m, table[i][j]);
			}
		}
	}

	return count;
}

// Пометить все точки острова.
// параметры:
// table - карта.
// n - кол-во строк.
// m - кол-во столбцов.
// point - текущая точка алгоритма поиска с возвратом.
void MarkIsland(Point** table, int n, int m, Point point)
{
	table[point.i][point.j].isMarked = true; // помечаем точку, как посещенную
	int possibleMove[4][2] = { {0,1}, {1,0}, {0,-1}, {-1,0} }; // возможные ходы (вправо/влево/вниз/вверх)

	for (int i = 0; i < 4; i++)
	{
		// предполагаем следующую точку, куда хотим сделать шаг
		int x = point.i + possibleMove[i][0];
		int y = point.j + possibleMove[i][1];

		if (x >= 0 && x < n && y >= 0 && y < m) // проверяем точку на доступность(не выходит ли за границы таблицы)
		{
			Point nextPoint = table[x][y]; 
			if (!nextPoint.isMarked && nextPoint.value == 1) // если эта точка не была посещена ранее и она суша, то рекурсивно применяем к ней этот же алгоритм.
			{
				MarkIsland(table, n, m, nextPoint);
			}
		}
	}
}

// Печать карты на экран.
// параметры:
// table - карта.
// n - кол-во строк.
// m - кол-во единиц.
void PrintTable(Point** table, int n, int m)
{
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cout << table[i][j].value << ' ';
		}
		cout << endl;
	}
}